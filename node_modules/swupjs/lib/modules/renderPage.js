'use strict';

var _Link = require('swup/lib/Link');

var _Link2 = _interopRequireDefault(_Link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var forEach = Array.prototype.forEach;


module.exports = function (page, popstate) {
    var _this = this;

    document.documentElement.classList.remove('is-leaving');

    // replace state in case the url was redirected
    var link = new _Link2.default();
    link.setPath(page.responseURL);

    if (window.location.pathname !== link.getPath()) {
        window.history.replaceState({
            url: link.getPath(),
            random: Math.random(),
            source: "swup"
        }, document.title, link.getPath());
    }

    if (!popstate || this.options.animateHistoryBrowsing) {
        document.documentElement.classList.add('is-rendering');
    }

    this.triggerEvent('willReplaceContent');

    // replace blocks
    for (var i = 0; i < page.blocks.length; i++) {
        document.body.querySelector('[data-swup="' + i + '"]').outerHTML = page.blocks[i];
    }

    // set title
    document.title = page.title;

    // handle classes after render
    // remove
    if (this.options.pageClassPrefix !== false) {
        document.body.className.split(' ').forEach(function (className) {
            // empty string for page class
            if (className != "" && className.includes(_this.options.pageClassPrefix)) {
                document.body.classList.remove(className);
            }
        });
    }

    // add
    if (page.pageClass != "") {
        page.pageClass.split(' ').forEach(function (className) {
            if (className != "" && className.includes(_this.options.pageClassPrefix)) {
                document.body.classList.add(className);
            }
        });
    }

    this.triggerEvent('contentReplaced');
    this.triggerEvent('pageView');

    if (!this.options.cache) {
        this.cache.empty(this.options.debugMode);
    }

    // scrolling
    if (!this.options.doScrollingRightAway || this.scrollToElement) {
        this.doScrolling(popstate);
    }

    // detect animation end
    var animationPromises = [];
    if (!popstate || this.options.animateHistoryBrowsing) {
        this.triggerEvent('animationInStart');
        var animationPromise = this.createAnimationPromise(this.getAnimation(this.transition, this.animations, 'in'));
        animationPromises.push(animationPromise);
    }

    //preload pages if possible
    this.preloadPages();

    if (!popstate || this.options.animateHistoryBrowsing) {
        Promise.all(animationPromises).then(function () {
            _this.triggerEvent('animationInDone');
            // remove "to-{page}" classes
            document.documentElement.className.split(' ').forEach(function (classItem) {
                if (new RegExp("^to-").test(classItem) || classItem === "is-changing" || classItem === "is-rendering" || classItem === "is-popstate") {
                    document.documentElement.classList.remove(classItem);
                }
            });
        });
    }

    // update current url
    this.getUrl();
    // reset scroll-to element
    this.scrollToElement = null;
};